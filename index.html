<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>–î–ª—è –º–æ–µ–π –ª—é–±–∏–º–æ–π ‚ù§Ô∏è</title>
<style>
body { margin:0; overflow:hidden; background:black; font-family:Arial, sans-serif; color:white;}
#overlay{position:absolute;width:100%;height:100%;display:flex;align-items:center;justify-content:center;z-index:10;cursor:pointer;}
#startText{font-size:32px;opacity:0.8;}
#finalMessage{position:absolute;width:100%;text-align:center;top:40%;font-size:48px;opacity:0;z-index:20;}
</style>
</head>
<body>

<div id="overlay">
  <div id="startText">–ù–∞–∂–º–∏ –Ω–∞ –ø–æ–¥–∞—Ä–æ–∫ üéÅ</div>
</div>

<div id="finalMessage">
  –Ø –ª—é–±–ª—é —Ç–µ–±—è, –º–æ—è –º–∏–ª–∞—è‚Ä¶<br>
  –° —Ç–æ–±–æ–π ‚Äî –Ω–∞–≤—Å–µ–≥–¥–∞ ‚ù§Ô∏è
</div>

<audio id="music1" src="1.mp3"></audio>
<audio id="music2" src="2.mp3"></audio>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script>
let scene, camera, renderer;
let gift, stars;
let stage = 1;
let clock = new THREE.Clock();
let photoMeshes = [];
let photoCount = 30;

init();
animate();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.z = 10;

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  createStars();
  createGift();
}

function createStars(){
  let geo = new THREE.BufferGeometry();
  let verts = [];
  for(let i=0;i<4000;i++){
    verts.push((Math.random()-0.5)*400,(Math.random()-0.5)*400,(Math.random()-0.5)*400);
  }
  geo.setAttribute("position", new THREE.Float32BufferAttribute(verts,3));
  let mat = new THREE.PointsMaterial({color:0xffffff,size:0.8,transparent:true});
  stars = new THREE.Points(geo,mat);
  scene.add(stars);
}

function createGift(){
  let geo = new THREE.BoxGeometry(3,3,3);
  let mat = new THREE.MeshStandardMaterial({color:0xff0040});
  gift = new THREE.Mesh(geo,mat);
  scene.add(gift);
}

document.getElementById("overlay").addEventListener("click",explodeGift);

function explodeGift(){
  document.getElementById("overlay").style.display="none";
  document.getElementById("music1").play();

  gsap.to(gift.scale,{x:6,y:6,z:6,duration:0.6});
  gsap.to(gift.material,{opacity:0,duration:0.6,onComplete:()=>{
    scene.remove(gift);
    showMoonScene();
    showPhotos();
  }});
}

function showMoonScene(){
  document.getElementById("music1").pause();
  document.getElementById("music2").play();

  scene.background = new THREE.Color(0x000011);

  let moonGeo = new THREE.SphereGeometry(1.5,32,32);
  let moonMat = new THREE.MeshBasicMaterial({color:0xffffcc});
  let moon = new THREE.Mesh(moonGeo,moonMat);
  moon.position.set(4,3,-3);
  scene.add(moon);

  gsap.to("#finalMessage",{opacity:1,duration:4});
}

function showPhotos(){
  const loader = new THREE.TextureLoader();
  for(let i=1;i<=photoCount;i++){
    loader.load(`photos/${i}.jpg`,texture=>{
      let geo = new THREE.PlaneGeometry(3,2);
      let mat = new THREE.MeshBasicMaterial({map:texture,transparent:true,opacity:0});
      let mesh = new THREE.Mesh(geo,mat);

      mesh.position.set(
        (Math.random()-0.5)*10,
        (Math.random()-0.5)*5,
        -Math.random()*5
      );

      scene.add(mesh);
      photoMeshes.push(mesh);

      // –ü–æ—è–≤–ª–µ–Ω–∏–µ –∫–∞–∫ –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏—è
      gsap.to(mesh.material,{opacity:1,duration:2,delay:i*0.5});
      gsap.to(mesh.position,{y:mesh.position.y+2,duration:2,delay:i*0.5});
      gsap.to(mesh.material,{opacity:0,duration:2,delay:i*0.5+3,onComplete:()=>scene.remove(mesh)});
    });
  }
}

function animate(){
  requestAnimationFrame(animate);

  if(gift){gift.rotation.x+=0.01; gift.rotation.y+=0.01;}

  stars.material.opacity = 0.7 + Math.sin(clock.getElapsedTime()*2)*0.3;
  camera.position.x = Math.sin(clock.getElapsedTime()*0.2)*1.5;
  camera.lookAt(scene.position);

  renderer.render(scene,camera);
}
</script>

</body>
</html>
